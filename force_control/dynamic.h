#pragma once
/*
* dynamic.h
*
*  Created on: Jul 21, 2018
*      Author: hqi
*/

#ifndef FORCE_CONTROL_ROBOT_DYNAMIC_INCLUDE_DYNAMIC_H_
#define FORCE_CONTROL_ROBOT_DYNAMIC_INCLUDE_DYNAMIC_H_


//----------------------------------------------------
#include "matrix.h"
#include "dynamic_profile.h"
#include "robot_ctl_utility.h"

//----------------------------------------------------
#pragma pack(4)
typedef struct DYNAMIC_PRM
{
	double m[JOINT_COORDINATE_NUM];  //mass of joints.
	double I[JOINT_COORDINATE_NUM];  //inertia of joint.
	double c[JOINT_COORDINATE_NUM];  //centroid of joint relative to each joint .
	double L[JOINT_COORDINATE_NUM];  //length of each joint.
	double fc0[JOINT_COORDINATE_NUM];  //kulun friction coefficient 1,when vel=0.
	double fc1[JOINT_COORDINATE_NUM];  //kulun friction coefficient 2,when vel!=0.
	double fv[JOINT_COORDINATE_NUM];  //dynamic friction coefficent.

	matxx Jm;  //inertia of motor.
	matxx Bm;  //friction of motor.
	matxx ratio;  //deceleration ratio of motor.
	matxx inv_ratio;  //inv of ratio matrix.
	matxx TorCoe;  //moment coefficient.

}dynamic_prm;
#pragma pack()

#pragma pack(4)
typedef struct DYNAMIC
{
	dynamic_prm 			dynamic_prm;
	//cartesian_dynamic 	    cart_dynamic;

	matxx		T;	 //torque in joint.
	matxx		Tx;	 //force in cartesian.
	matxx		M;  //inertia matrix in joint.
	matxx		C;  //centrifugal and Coriolis matrix in joint.
	matxx 		G;  //gravity matxx in joint.
	matxx		F;  //friction matxx in joint.

	matxx		Tm;  //torque generated by motor.
	matxx		CURm;  //current flow through motor

	//--------- adaptive control --------
	matxx       Y;    //regressor matxx Y(q,qd,qdd)
	matxx       cof;    //T=Y*cof
	matxx       cofd;    //cofd=d cof/dt
	matxx       Ga;    //inverse of Gama

	matxx       tmp42;
	matxx       tmp41;
	matxx       temp41;
	matxx		tmp44;
	matxx		temp44;
	matxx		tmp22;
	matxx		tmp24;
	//----------addendum------
	Uint8		tor_add_flag;
	matxx		C_add;  //C_add = C(dE/dt + K1*E) ; C is centrifugal and Coriolis matrix in joint.
	matxx		T_add;  //T_add = K2*dE/dt + K3*E
	double		K1;  //coefficient
	double		K2;  //coefficient
	double		K3;  //coefficient

	Uint8       en_int_flag;
	double		max_tur[JOINT_COORDINATE_NUM];  //max torque generatored by integral.
	matxx		int_E;  //integral of E
	double		K4;  //T_add = K2*dE/dt + K3*E + K4*integral(E)
	//------------------------

	int16(*pfInitDynamic)(struct DYNAMIC* m_dym);


}dynamic;
#pragma pack()

int16 InitDynamic(dynamic* m_dym);

int16 calculate_dynamic_module(dynamic* m_dym, joint_profile* p_joint, cartesian_profile* p_cart, dynamic_prm* p_prm);

#endif /* FORCE_CONTROL_ROBOT_DYNAMIC_INCLUDE_DYNAMIC_H_ */






